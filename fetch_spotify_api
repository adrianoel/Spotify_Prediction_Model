###  fetches the spotify api data (adjustable) ###

from dotenv import load_dotenv
import csv
import os
import spotipy
from spotipy.oauth2 import SpotifyOAuth

def fetch_recent_tracks_data(limit=50):
    """
    Fetches the recently played tracks data from your personal Spotify API.

    Args: 
        limit (int): Number of tracks to fetch (default is 50).
    
    Returns:
        results (list): List of track data dictionaries.
    """

    # read the .env file (credentials for the api) and save them variables
    load_dotenv()
    sp_cred = spotipy.Spotify(auth_manager=SpotifyOAuth(
        client_id=os.getenv('SPOTIFY_CLIENT_ID'),
        client_secret=os.getenv('SPOTIFY_CLIENT_SECRET'),
        redirect_uri=os.getenv('SPOTIFY_REDIRECT_URI'),
        scope='user-read-recently-played user-library-read'
    ))

    # fetch recently played tracks (with max limit)
    results = sp_cred.current_user_recently_played(limit=limit)

    return results
### above code works, tested in jupyter notebook ###

def create_track_list(results):
    """
    Creates a list of track data dictionaries from the Spotify API results.
    """

    # get track data from results
    tracks_list = []
    for item in results['items']:
        track = item['track']
        track_id = track['id']

        # fetch audio features for the track
        features = sp_cred.audio_features([track_id])[0]

        # check if features (audio features) are available, then continue loop
        if not features:
            continue

        # get artist genres
        artist_id = track['artists'][0]['id']
        artist_info = sp_cred.artist[artist_id]
        genres = artist_info('genres', [])

        # get all audio features in a track_data dictionary
        track_data = {
                'track_id': track_id,
                'artists': ', '.join(entry['name'] for entry in track['artists']),
                'album_name': track['album']['name'],
                'track_name': track['name'],,
                'popularity': track['popularity'],
                'duration_ms': track['duration_ms'],
                'explicit': track['explicit'],
                'danceability': features['danceability'],
                'energy': features['energy'],
                'key': features['key'],
                'loudness': features['loudness'],
                'mode': features['mode'],
                'speechiness': features['speechiness'],
                'acousticness': features['acousticness'],
                'instrumentalness': features['instrumentalness'],
                'liveness': features['liveness'],
                'valence': features['valence'],
                'tempo': features['tempo'],
                'time_signature': features['time_signature'],
                'track_genre': genres[0] if genres else None
            }

            tracks_list.append(track_data)

    
    



# check columns and their order with original kaggle 30k spotify dataset
kaggle_spotify_dataset_columns = ['track_id', 'artists', 'album_name', 'track_name', 'popularity',
                                'duration_ms', 'explicit', 'danceability', 'energy', 'key', 'loudness',
                                'mode', 'speechiness', 'acousticness', 'instrumentalness', 'liveness',
                                'valence', 'tempo', 'time_signature', 'track_genre']
assert list(tracks_list[0].keys()) == kaggle_spotify_dataset_columns, "Columns do not match the original dataset"

# ensure /data folder exists
data_dir = os.path.join(os.getcwd(), 'data')
if not os.path.exists(data_dir):
    os.makedirs(data_dir, exist_ok=True)

# save tracks_list to csv file
csv_filename = 'personal_spotify_data.csv'
with open(csv_filename, mode='w', newline='', encoding='utf-8') as f:
    writer = csv.DictWriter(f, fieldnames=tracks_list[0].keys())
    writer.writeheader()
    writer.writerows(tracks_list)

print(f'Saved {len(tracks_list)} tracks to {csv_filename}')